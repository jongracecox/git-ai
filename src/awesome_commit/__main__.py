import argparse
import sys
from enum import Enum

import jinja2
from colored import Fore, Style
from google import genai
from google.genai import types
from loguru import logger
from questionary import select

from awesome_commit.editor import edit_text
from awesome_commit.git import (
    commit_changes,
    get_git_changes,
    get_last_commit_messages,
    show_diff,
    git_has_staged_changes,
)
from awesome_commit.pre_commit import run_pre_commit
from awesome_commit.config import AppConfig as config


def get_prompt(context: dict) -> str:
    """Generate a prompt using a Jinja template.

    Args:
        context (dict): The context to render the template with.
    """
    jinja_template = config.PROMPT_TEMPLATE
    if not jinja_template.exists():
        raise FileNotFoundError(f"Prompt template not found: {jinja_template}")

    with open(jinja_template, "r") as f:
        template = jinja2.Template(f.read())

    prompt = template.render(**context)

    return prompt


def get_commit_message():
    """Generate a commit message using the Gemini API."""
    print(f"{Fore.blue}Creating Gemini API client{Style.reset}")
    client = genai.Client(api_key=config.GEMINI_API_KEY)

    git_unified_diff = get_git_changes()
    commit_messages = get_last_commit_messages(config.NUM_PREVIOUS_COMMITS)

    context = {
        "commit_messages": commit_messages,
        "num_previous_commits": config.NUM_PREVIOUS_COMMITS,
        "git_unified_diff": git_unified_diff,
    }

    print(f"{Fore.blue}Generating prompt...{Style.reset}")
    prompt = get_prompt(context=context)

    logger.debug("Prompt:")
    for line in prompt.splitlines():
        logger.debug(line)

    print(f"{Fore.blue}Submitting prompt to Gemini API{Style.reset}")
    response = client.models.generate_content(
        model=config.AI_MODEL,
        config=types.GenerateContentConfig(
            system_instruction=(
                "You are a technical writer for a software company "
                "and write succinctly."
            ),
        ),
        contents=prompt,
    )

    logger.debug("Generated commit message:")
    for line in response.text.splitlines():
        logger.debug(line)

    return response.text


def parse_args() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Commit changes with a message generated by the Gemini API."
    )
    parser.add_argument("--logging", action="store_true", help="Enable logging.")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging.")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the commit message without committing the changes.",
    )
    return parser.parse_args()


class UserChoice(Enum):
    """Choices for the user to accept, edit, or regenerate the commit message."""

    YES = "Yes (Commit)"
    NO = "No (Regenerate)"
    EDIT = "Edit"
    SHOW_DIFF = "Show diff"
    QUIT = "Quit"


def main(dry_run: bool = False):
    """Main function."""

    print(f"{Fore.blue}Git AI{Style.reset}")

    if not git_has_staged_changes():
        print(f"{Fore.red}No staged changes found. Exiting.{Style.reset}")
        sys.exit(0)

    if config.RUN_PRE_COMMIT:
        run_pre_commit()

    message_accepted = False
    generate_message = True

    while not message_accepted:
        if generate_message:
            commit_message = get_commit_message()
        if not commit_message:
            print(f"{Fore.red}No commit message generated. Exiting.{Style.reset}")
            sys.exit(1)
        for line in commit_message.splitlines():
            print(f"{Fore.yellow}{line}{Style.reset}")
        if dry_run:
            print(
                f"{Fore.red}NOTE: You are in dry-run mode. This commit message will not be used.{Style.reset}"
            )
        value = select(
            "Do you want to use this commit message?",
            choices=[choice.value for choice in UserChoice],
            default=UserChoice.YES.value,
        ).ask()
        if value is None:
            print(f"{Fore.blue}Exiting without committing changes.{Style.reset}")
            sys.exit(0)
        elif value == UserChoice.YES.value:
            message_accepted = True
        elif value == UserChoice.NO.value:
            generate_message = True
        elif value == UserChoice.EDIT.value:
            print(
                f"{Fore.blue}Opening commit message in your default text editor.{Style.reset}"
            )
            commit_message = edit_text(commit_message)
            generate_message = False
        elif value == UserChoice.SHOW_DIFF.value:
            show_diff()
            generate_message = False
        elif value == UserChoice.QUIT.value:
            print(f"{Fore.blue}Exiting without committing changes.{Style.reset}")
            sys.exit(0)

    if dry_run:
        print(f"{Fore.blue}Dry run enabled. Skipping commit.{Style.reset}")
    else:
        print(f"{Fore.blue}Committing changes with the generated message:{Style.reset}")
        commit_changes(commit_message)
        print(f"{Fore.blue}Changes committed.{Style.reset}")


if __name__ == "__main__":
    args = parse_args()

    if args.logging:
        if args.debug:
            logger.remove()
            logger.add(sys.stderr, level="DEBUG")
    else:
        logger.remove()

    main(dry_run=args.dry_run)

    logger.info("Done.")
