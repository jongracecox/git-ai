import argparse
import sys
from enum import Enum
from pathlib import Path

import jinja2
from colored import Fore, Style
from decouple import config
from google import genai
from google.genai import types
from loguru import logger
from questionary import select

from editor import edit_text
from git import (
    commit_changes,
    get_git_changes,
    get_last_commit_messages,
    show_diff,
)
from pre_commit import run_pre_commit

GEMINI_API_KEY = config("GEMINI_API_KEY")
NUM_PREVIOUS_COMMITS = config("NUM_PREVIOUS_COMMITS", default=3, cast=int)
SRC_DIR = Path(__file__).parent
PROMPTS_DIR = Path(config("PROMPTS_DIR", default=str(SRC_DIR / "prompts")))
RUN_PRE_COMMIT = config("RUN_PRE_COMMIT", default=True, cast=bool)

# GEMINI_AI_MODEL = "gemini-2.0-flash"
GEMINI_AI_MODEL = "gemini-2.5-flash-preview-04-17"


def get_prompt(name: str, context: dict) -> str:
    """Generate a prompt using a Jinja template.

    Args:
        name (str): The name of the prompt template file (without the extension).
        context (dict): The context to render the template with.
    """
    jinja_template = PROMPTS_DIR / f"{name}.txt.jinja2"
    if not jinja_template.exists():
        raise FileNotFoundError(f"Prompt template not found: {jinja_template}")

    with open(jinja_template, "r") as f:
        template = jinja2.Template(f.read())

    prompt = template.render(**context)

    return prompt


def get_commit_message():
    """Generate a commit message using the Gemini API."""
    print(f"{Fore.blue}Creating Gemini API client{Style.reset}")
    client = genai.Client(api_key=GEMINI_API_KEY)

    git_unified_diff = get_git_changes()
    commit_messages = get_last_commit_messages(NUM_PREVIOUS_COMMITS)

    context = {
        "commit_messages": commit_messages,
        "num_previous_commits": NUM_PREVIOUS_COMMITS,
        "git_unified_diff": git_unified_diff,
    }

    print(f"{Fore.blue}Generating prompt...{Style.reset}")
    prompt = get_prompt(name="generate_commit_message", context=context)

    logger.debug("Prompt:")
    for line in prompt.splitlines():
        logger.debug(line)

    print(f"{Fore.blue}Submitting prompt to Gemini API{Style.reset}")
    response = client.models.generate_content(
        model=GEMINI_AI_MODEL,
        config=types.GenerateContentConfig(
            system_instruction=("You are a technical writer for a software company " "and write succinctly."),
        ),
        contents=prompt,
    )

    logger.debug("Generated commit message:")
    for line in response.text.splitlines():
        logger.debug(line)

    return response.text


def parse_args() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Commit changes with a message generated by the Gemini API.")
    parser.add_argument("--logging", action="store_true", help="Enable logging.")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging.")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the commit message without committing the changes.",
    )
    return parser.parse_args()


class UserChoice(Enum):
    """Choices for the user to accept, edit, or regenerate the commit message."""

    YES = "Yes (Commit)"
    NO = "No (Regenerate)"
    EDIT = "Edit"
    SHOW_DIFF = "Show diff"
    QUIT = "Quit"


def main(dry_run: bool = False):
    """Main function."""

    if RUN_PRE_COMMIT:
        run_pre_commit()

    message_accepted = False
    generate_message = True

    while not message_accepted:
        if generate_message:
            commit_message = get_commit_message()
        for line in commit_message.splitlines():
            print(f"{Fore.yellow}{line}{Style.reset}")
        if dry_run:
            print(
                f"{Fore.red}NOTE: You are in dry-run mode. This commit message will not be used.{Style.reset}"
            )
        value = select(
            "Do you want to use this commit message?",
            choices=[choice.value for choice in UserChoice],
            default=UserChoice.YES.value,
        ).ask()
        if value is None:
            print(f"{Fore.blue}Exiting without committing changes.{Style.reset}")
            sys.exit(0)
        elif value == UserChoice.YES.value:
            message_accepted = True
        elif value == UserChoice.NO.value:
            generate_message = True
        elif value == UserChoice.EDIT.value:
            print(f"{Fore.blue}Opening commit message in your default text editor.{Style.reset}")
            commit_message = edit_text(commit_message)
            generate_message = False
        elif value == UserChoice.SHOW_DIFF.value:
            show_diff()
            generate_message = False
        elif value == UserChoice.QUIT.value:
            print(f"{Fore.blue}Exiting without committing changes.{Style.reset}")
            sys.exit(0)

    if dry_run:
        print(f"{Fore.blue}Dry run enabled. Skipping commit.{Style.reset}")
    else:
        print(f"{Fore.blue}Committing changes with the generated message:{Style.reset}")
        commit_changes(commit_message)
        print(f"{Fore.blue}Changes committed.{Style.reset}")


if __name__ == "__main__":

    args = parse_args()

    if args.logging:
        if args.debug:
            logger.remove()
            logger.add(sys.stderr, level="DEBUG")
    else:
        logger.remove()

    main(dry_run=args.dry_run)

    logger.info("Done.")
